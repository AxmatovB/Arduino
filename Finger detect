#include <SPI.h>

// ====== PINS (UNO) ======
#define TFT_DC   9
#define TFT_RST  8

// ====== RGB565 COLORS ======
const uint16_t C_BLACK = 0x0000; // фон
const uint16_t C_GREEN = 0x07E0; // ярко-зелёный

// ====== Low-level SPI helpers ======
static inline void tftCmd(uint8_t c) {
  digitalWrite(TFT_DC, LOW);
  SPI.transfer(c);
}
static inline void tftData(uint8_t d) {
  digitalWrite(TFT_DC, HIGH);
  SPI.transfer(d);
}
static inline void tftData16(uint16_t d) {
  digitalWrite(TFT_DC, HIGH);
  SPI.transfer(d >> 8);
  SPI.transfer(d & 0xFF);
}

void tftReset() {
  digitalWrite(TFT_RST, LOW); delay(50);
  digitalWrite(TFT_RST, HIGH); delay(120);
}

void tftSetWindow(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1) {
  tftCmd(0x2A); // CASET
  tftData16(x0); tftData16(x1);
  tftCmd(0x2B); // RASET
  tftData16(y0); tftData16(y1);
  tftCmd(0x2C); // RAMWR
}

void tftFillRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color) {
  if (x >= 240 || y >= 240) return;
  if (x + w > 240) w = 240 - x;
  if (y + h > 240) h = 240 - y;

  tftSetWindow(x, y, x + w - 1, y + h - 1);
  digitalWrite(TFT_DC, HIGH);

  uint32_t n = (uint32_t)w * (uint32_t)h;
  for (uint32_t i = 0; i < n; i++) {
    SPI.transfer(color >> 8);
    SPI.transfer(color & 0xFF);
  }
}

void tftFillScreen(uint16_t color) {
  tftFillRect(0, 0, 240, 240, color);
}

void tftInitST7789() {
  tftReset();

  SPI.begin();
  SPI.beginTransaction(SPISettings(4000000, MSBFIRST, SPI_MODE0)); // UNO-friendly

  tftCmd(0x11); delay(120);    // Sleep Out
  tftCmd(0x3A); tftData(0x55); // 16-bit color
  tftCmd(0x36); tftData(0x00); // Rotation базовый
  tftCmd(0x29); delay(20);     // Display ON

  SPI.endTransaction();
}

// ===== 7-seg digit drawing =====
// Segment bit order: A B C D E F G
void draw7Seg(uint8_t digit, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t thick, uint16_t color) {
  // Clear digit area (BLACK background)
  tftFillRect(x, y, w, h, C_BLACK);

  uint16_t pad = thick;
  uint16_t segLenH = w - 2 * pad;
  uint16_t segLenV = (h - 3 * thick) / 2;

  auto segA = [&](){ tftFillRect(x + pad, y, segLenH, thick, color); };
  auto segD = [&](){ tftFillRect(x + pad, y + h - thick, segLenH, thick, color); };
  auto segG = [&](){ tftFillRect(x + pad, y + thick + segLenV, segLenH, thick, color); };
  auto segF = [&](){ tftFillRect(x, y + thick, thick, segLenV, color); };
  auto segE = [&](){ tftFillRect(x, y + 2*thick + segLenV, thick, segLenV, color); };
  auto segB = [&](){ tftFillRect(x + w - thick, y + thick, thick, segLenV, color); };
  auto segC = [&](){ tftFillRect(x + w - thick, y + 2*thick + segLenV, thick, segLenV, color); };

  const uint8_t map[10] = {
    0b1111110, // 0
    0b0110000, // 1
    0b1101101, // 2
    0b1111001, // 3
    0b0110011, // 4
    0b1011011, // 5
    0b1011111, // 6
    0b1110000, // 7
    0b1111111, // 8
    0b1111011  // 9
  };

  uint8_t bits = map[digit % 10];

  if (bits & 0b1000000) segA();
  if (bits & 0b0100000) segB();
  if (bits & 0b0010000) segC();
  if (bits & 0b0001000) segD();
  if (bits & 0b0000100) segE();
  if (bits & 0b0000010) segF();
  if (bits & 0b0000001) segG();
}

uint8_t lastShown = 255; // 255 = hech nima ko'rsatilmagan

void showDigit(uint8_t d) {
  SPI.beginTransaction(SPISettings(4000000, MSBFIRST, SPI_MODE0));
  tftFillScreen(C_BLACK);                 // BLACK background
  if (d >= 1 && d <= 9) {
    draw7Seg(d, 60, 40, 120, 160, 12, C_GREEN); // GREEN digit
  }
  SPI.endTransaction();
}

void setup() {
  Serial.begin(115200);

  pinMode(TFT_DC, OUTPUT);
  pinMode(TFT_RST, OUTPUT);

  tftInitST7789();
  showDigit(0); // start: qora fon
}

void loop() {
  // PC dan '1'..'5' keladi (newline bo'lsa ham ok)
  while (Serial.available() > 0) {
    int ch = Serial.read();

    if (ch >= '1' && ch <= '5') {
      uint8_t d = (uint8_t)(ch - '0');
      if (d != lastShown) {
        lastShown = d;
        showDigit(d);
      }
    }
    // qolgan belgilarni (masalan '\n' '\r') ignore qilamiz
  }
}
